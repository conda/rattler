use create_shortcut::Shortcut;
use fs_err as fs;
use rattler_conda_types::Platform;
use rattler_shell::{
    activation::{ActivationVariables, Activator},
    shell,
};
use registry::{notify_shell_changes, FileExtension, UrlProtocol};
use std::{
    io::Write as _,
    path::{Path, PathBuf},
};

use crate::{
    render::{BaseMenuItemPlaceholders, MenuItemPlaceholders},
    schema::{Environment, MenuItemCommand, Windows},
    slugify,
    tracker::WindowsTracker,
    util::log_output,
    MenuInstError, MenuMode,
};

mod create_shortcut;
mod knownfolders;
mod lex;
mod registry;

use knownfolders::UserHandle;

pub struct Directories {
    start_menu: PathBuf,
    quick_launch: Option<PathBuf>,
    desktop: PathBuf,
}

fn shortcut_filename(name: &str, env_name: Option<&String>, ext: Option<&str>) -> String {
    let env = if let Some(env_name) = env_name {
        format!(" ({env_name})")
    } else {
        "".to_string()
    };

    let ext = ext.unwrap_or("lnk");
    format!("{name}{env}{ext}")
}

/// On Windows we can create shortcuts in several places:
/// - Start Menu
/// - Desktop
/// - Quick launch (only for user installs)
impl Directories {
    pub fn create(menu_mode: MenuMode) -> Directories {
        let user_handle = match menu_mode {
            MenuMode::System => UserHandle::Common,
            MenuMode::User => UserHandle::Current,
        };

        let known_folders = knownfolders::Folders::new();
        let start_menu = known_folders.get_folder_path("start", user_handle).unwrap();
        let quick_launch = if menu_mode == MenuMode::User {
            known_folders
                .get_folder_path("quick_launch", user_handle)
                .ok()
        } else {
            None
        };
        let desktop = known_folders
            .get_folder_path("desktop", user_handle)
            .unwrap();

        Directories {
            start_menu,
            quick_launch,
            desktop,
        }
    }
}

pub struct WindowsMenu {
    prefix: PathBuf,
    name: String,
    item: Windows,
    command: MenuItemCommand,
    directories: Directories,
    placeholders: MenuItemPlaceholders,
    menu_mode: MenuMode,
}

const SHORTCUT_EXTENSION: &str = "lnk";

impl WindowsMenu {
    pub fn new(
        prefix: &Path,
        item: Windows,
        command: MenuItemCommand,
        directories: Directories,
        placeholders: &BaseMenuItemPlaceholders,
        menu_mode: MenuMode,
    ) -> Self {
        let name = command.name.resolve(Environment::Base, placeholders);

        let shortcut_name = shortcut_filename(
            &name,
            placeholders.as_ref().get("ENV_NAME"),
            Some(SHORTCUT_EXTENSION),
        );

        let location = directories
            .start_menu
            .join(&shortcut_name)
            .with_extension(SHORTCUT_EXTENSION);

        // self.menu.start_menu_location / self._shortcut_filename()
        Self {
            prefix: prefix.to_path_buf(),
            name,
            item,
            command,
            directories,
            placeholders: placeholders.refine(&location),
            menu_mode,
        }
    }

    fn script_content(&self) -> Result<String, MenuInstError> {
        let mut lines = vec![
            "@echo off".to_string(),
            ":: Script generated by conda/menuinst".to_string(),
        ];

        if let Some(pre_command_code) = self.command.precommand.as_ref() {
            lines.push(pre_command_code.resolve(&self.placeholders));
        }

        if self.command.activate.unwrap_or_default() {
            // create a bash activation script and emit it into the script
            let activator =
                Activator::from_path(&self.prefix, shell::CmdExe, Platform::current()).unwrap();
            let activation_env = activator.run_activation(ActivationVariables::default(), None)?;

            for (k, v) in activation_env {
                lines.push(format!(r#"set "{k}={v}""#));
            }
        }

        let args: Vec<String> = self
            .command
            .command
            .iter()
            .map(|elem| elem.resolve(&self.placeholders))
            .collect();

        lines.push(lex::quote_args(&args).join(" "));

        Ok(lines.join("\n"))
    }

    fn shortcut_filename(&self, ext: Option<&str>) -> String {
        shortcut_filename(&self.name, self.placeholders.as_ref().get("ENV_NAME"), ext)
    }

    fn write_script(&self, path: &Path) -> Result<(), MenuInstError> {
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }

        let mut file = fs::File::create(path)?;
        file.write_all(self.script_content()?.as_bytes())?;

        Ok(())
    }

    fn path_for_script(&self) -> PathBuf {
        self.prefix
            .join("Menu")
            .join(self.shortcut_filename(Some("bat")))
    }

    fn build_command(&self, with_arg1: bool) -> Result<Vec<String>, MenuInstError> {
        if self.command.activate.unwrap_or(false) {
            let script_path = self.path_for_script();
            self.write_script(&script_path)?;

            let system_root = std::env::var("SystemRoot").unwrap_or("C:\\Windows".to_string());
            let system32 = Path::new(&system_root).join("system32");
            let cmd_exe = system32.join("cmd.exe").to_string_lossy().to_string();

            if self.command.terminal.unwrap_or(false) {
                let mut command = [&cmd_exe, "/D", "/K"]
                    .iter()
                    .map(|s| (*s).to_string())
                    .collect::<Vec<String>>();

                // add script path with quotes
                command.push(format!("\"{}\"", script_path.to_string_lossy()));

                if with_arg1 {
                    command.push("%1".to_string());
                }
                Ok(command)
            } else {
                let script_path = self.path_for_script();
                self.write_script(&script_path)?;

                let arg1 = if with_arg1 { "%1 " } else { "" };
                let powershell = system32
                    .join("WindowsPowerShell")
                    .join("v1.0")
                    .join("powershell.exe")
                    .to_string_lossy()
                    .to_string();

                let mut command = [
                    &cmd_exe,
                    "/D",
                    "/C",
                    "START",
                    "/MIN",
                    "\"\"",
                    &powershell,
                    "-WindowStyle",
                    "hidden",
                ]
                .iter()
                .map(ToString::to_string)
                .collect::<Vec<String>>();

                command.push(format!(
                    "\"start '{}' {}-WindowStyle hidden\"",
                    script_path.to_string_lossy(),
                    arg1
                ));

                Ok(command)
            }
        } else {
            let mut command = Vec::new();
            for elem in self.command.command.iter() {
                command.push(elem.resolve(&self.placeholders));
            }

            if with_arg1 && !command.iter().any(|s| s.contains("%1")) {
                command.push("%1".to_string());
            }

            Ok(command)
        }
    }

    fn precreate(&self) -> Result<(), MenuInstError> {
        if let Some(precreate_code) = self.command.precreate.as_ref() {
            let precreate_code = precreate_code.resolve(&self.placeholders);

            if precreate_code.is_empty() {
                return Ok(());
            }

            let mut temp_file = tempfile::NamedTempFile::with_suffix(".bat")?;
            temp_file.write_all(precreate_code.as_bytes())?;

            // Close file and keep temporary path around
            let path = temp_file.into_temp_path();

            let output = std::process::Command::new("cmd")
                .arg("/c")
                .arg(&path)
                .output()?;

            log_output("precreate", output);
        }
        Ok(())
    }

    fn app_id(&self) -> String {
        match self.item.app_user_model_id.as_ref() {
            Some(aumi) => aumi.resolve(&self.placeholders),
            None => format!(
                "Menuinst.{}",
                slugify(&self.name)
                    .replace(".", "")
                    .chars()
                    .take(128)
                    .collect::<String>()
            ),
        }
    }

    fn create_shortcut(
        &self,
        args: &[String],
        tracker: &mut WindowsTracker,
    ) -> Result<(), MenuInstError> {
        let icon = self
            .command
            .icon
            .as_ref()
            .map(|s| s.resolve(&self.placeholders));

        let workdir = if let Some(workdir) = &self.command.working_dir {
            workdir.resolve(&self.placeholders)
        } else {
            "%HOMEPATH%".to_string()
        };

        if workdir != "%HOMEPATH%" {
            fs::create_dir_all(&workdir)?;
        }

        let app_id = self.app_id();

        // split args into command and arguments
        let (command, args) = args.split_first().unwrap();
        let args = lex::quote_args(args).join(" ");

        let link_name = format!("{}.lnk", self.name);
        if self.item.desktop.unwrap_or(true) {
            let desktop_link_path = self.directories.desktop.join(&link_name);
            let shortcut = Shortcut {
                path: command,
                description: &self.command.description.resolve(&self.placeholders),
                filename: &desktop_link_path,
                arguments: Some(&args),
                workdir: Some(&workdir),
                iconpath: icon.as_deref(),
                iconindex: Some(0),
                app_id: Some(&app_id),
            };

            create_shortcut::create_shortcut(shortcut)?;
            tracker.files.push(desktop_link_path.clone());
        }

        if let Some(quick_launch_dir) = self.directories.quick_launch.as_ref() {
            if self.item.quicklaunch.unwrap_or(true) {
                let quicklaunch_link_path = quick_launch_dir.join(link_name);
                let shortcut = Shortcut {
                    path: &self.name,
                    description: &self.command.description.resolve(&self.placeholders),
                    filename: &quicklaunch_link_path,
                    arguments: Some(&args),
                    workdir: Some(&workdir),
                    iconpath: icon.as_deref(),
                    iconindex: Some(0),
                    app_id: Some(&app_id),
                };

                create_shortcut::create_shortcut(shortcut)?;
                tracker.files.push(quicklaunch_link_path.clone());
            }
        }
        Ok(())
    }

    fn icon(&self) -> Option<String> {
        self.command
            .icon
            .as_ref()
            .map(|s| s.resolve(&self.placeholders))
    }

    fn register_file_extensions(&self, tracker: &mut WindowsTracker) -> Result<(), MenuInstError> {
        let Some(extensions) = &self.item.file_extensions else {
            return Ok(());
        };

        let icon = self.icon();
        let command = self.build_command(true)?.join(" ");
        let name = &self.name;
        let app_user_model_id = self.app_id();

        for extension in extensions {
            let identifier = format!("{name}.AssocFile{extension}");

            let file_extension = FileExtension {
                extension,
                identifier: &identifier,
                command: &command,
                icon: icon.as_deref(),
                app_name: Some(name),
                app_user_model_id: Some(&app_user_model_id),
                friendly_type_name: None,
            };

            registry::register_file_extension(file_extension, self.menu_mode)?;

            tracker
                .file_extensions
                .push((extension.clone(), identifier));
        }

        Ok(())
    }

    fn register_url_protocols(&self, tracker: &mut WindowsTracker) -> Result<bool, MenuInstError> {
        let protocols = match &self.item.url_protocols {
            Some(protocols) if !protocols.is_empty() => protocols,
            _ => return Ok(false),
        };

        let command = self.build_command(true)?.join(" ");
        let icon = self.icon();
        let name = &self.name;
        let app_user_model_id = format!("{name}.Protocol");

        for protocol in protocols {
            let identifier = format!("{name}.Protocol{protocol}");

            let url_protocol = UrlProtocol {
                protocol,
                command: &command,
                identifier: &identifier,
                icon: icon.as_deref(),
                app_name: Some(name),
                app_user_model_id: Some(&app_user_model_id),
            };

            registry::register_url_protocol(url_protocol, self.menu_mode)?;
            tracker.url_protocols.push((protocol.clone(), identifier));
        }

        Ok(true)
    }

    pub fn install(&self, tracker: &mut WindowsTracker) -> Result<(), MenuInstError> {
        let args = self.build_command(false)?;
        self.precreate()?;
        self.create_shortcut(&args, tracker)?;
        self.register_file_extensions(tracker)?;
        self.register_url_protocols(tracker)?;
        notify_shell_changes();
        Ok(())
    }
}

pub(crate) fn install_menu_item(
    prefix: &Path,
    windows_item: Windows,
    command: MenuItemCommand,
    placeholders: &BaseMenuItemPlaceholders,
    menu_mode: MenuMode,
) -> Result<WindowsTracker, MenuInstError> {
    let mut tracker = WindowsTracker::new(menu_mode);
    tracker.menu_mode = menu_mode;
    let menu = WindowsMenu::new(
        prefix,
        windows_item,
        command,
        Directories::create(menu_mode),
        placeholders,
        menu_mode,
    );
    menu.install(&mut tracker)?;
    Ok(tracker)
}

pub(crate) fn remove_menu_item(tracker: &WindowsTracker) -> Result<(), MenuInstError> {
    for file in &tracker.files {
        fs::remove_file(file)?;
    }

    let menu_mode = tracker.menu_mode;
    for (extension, identifier) in &tracker.file_extensions {
        registry::unregister_file_extension(extension, identifier, menu_mode)?;
    }

    for (protocol, identifier) in &tracker.url_protocols {
        registry::unregister_url_protocol(protocol, identifier, menu_mode)?;
    }

    notify_shell_changes();
    Ok(())
}
